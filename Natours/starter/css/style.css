/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/* remove any browser inserted padding and margin
automatically select all elements and all after and before pseudo elements and apply the same behavior to pseudo elements
*/
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  /* better practice. Force inheritance. By itself box-sizing is not inherited.
  Tells each block element on the page to inherit body border-box properties.
  This technique makes it easy to change box-sizing for plugins, etc */
  box-sizing: inherit;
}

html {
  /* set root font size */
  /* em is much more difficult. It takes parent's element size to calculate sizes */
  /* if I hardcode 10px, this becomes root size, and the users will not be able to override it.
  The proper way is to use %. We know that the default browser font size is 16px. 
  We want it 10px. 10 / 16 = 62.5%. This allows user to zoom in on the page  */
  font-size: 62.5%;
}

body {
  /* properties related to font are inherited (except input elements).
       By setting fonts at the body level we pass them thru inheritance to children

    */
  font-family: "Lato", sans-serif;
  font-weight: 400;

  /* 1.7 times bigger than default */
  line-height: 1.7;
  color: #777;
  padding: 3rem;

  /* better practice to put this property on the body */
  /* change the box model, so borders and paddings are not added to the total width or height*/
  box-sizing: border-box;
}

.header {
  /* 95% of the view port height */
  height: 95vh;
  /* technically, 2 images. radient at the top, hero at the bottom 
  start gradient on the left top side and go to the right bottom
  */
  background-image: linear-gradient(
      to right bottom,
      /* make gradient transparent */ rgba(126, 213, 111, 0.8),
      rgba(40, 180, 131, 0.8)
    ),
    url(../img/hero.jpg);
  /* fit the element inside of the box whatever the view port is */
  background-size: cover;
  /* if shrinking the image from bottom or the browser, the top portion stays in view if top is selected,
  bottom portion stays in view if bottom is selected */
  background-position: top;

  /* specify four corners starting (x, y) top/left, top/right, etc 
  https://bennettfeely.com/clippy/ - resources for different shapes
  */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  position: relative;
}

.header__logo-box {
  position: absolute;
  top: 4rem;
  left: 4rem;
}

.header__logo {
  /* width will be automatically calculated by the browser if height if specified
    and vice versa */
  height: 3.5rem;
}

.header__text-box {
  /* center the text */
  position: absolute;
  /* start text 50% from the parent element top (header is the element which has position: relative )*/
  top: 40%;
  /* start text 50% from the left from the parent element left*/
  left: 50%;
  /* after positioned as stated above, shift 50% to the top and left. relative to itself.
  this concludes centering 
  transform works relative to the element on which it is declared, not the parent */
  transform: translate(-50%, -50%);
  text-align: center;
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  /* at the end of the animation this element slightly moves. To prevent this, use below rule */
  /* during animation, if we rotate an element, at some point the back part will be shown. To prevent it,
  use this rule. This is the primary use for this rule. In this specific case it just helps with extra shake */
  backface-visibility: hidden;

  margin-bottom: 6rem;
}

.heading-primary--main {
  /* by default span is inline element 
       inline elements occupy only as much space as they need. Block elements occupy the entire width available and put 
       line breaks at the end
    */
  display: block;
  font-size: 6rem;
  font-weight: 400;
  letter-spacing: 3.5rem;
  /* animation properties */
  animation-name: moveInLeft;
  animation-duration: 1s;

  /* wait 3 seconds before doing animation */
  /* animation-delay: 3s; */

  /* repeat animation 3 times */
  /* animation-iteration-count: 3; */

  /* speed at which animation takes place: 
     ease-in: start slow, and speed up at the end
     ease-out: start fast, finish slow.
  */
  animation-timing-function: ease-out;
}

.heading-primary--sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.74rem;

  animation-name: moveInRight;
  animation-duration: 1s;
}

@keyframes moveInLeft {
  /* when animation starts */
  0% {
    opacity: 0;
    /* move it to the 100rem to the left from current position */
    transform: translateX(-10rem);
  }

  /* before completing animation, shift it 10% to the right, then shift it to normal (0) when at 100%*/
  80% {
    transform: translateX(1rem);
  }

  /* when animation finishes */
  100% {
    opacity: 1;
    /* at the end show it the way it looks without animation*/
    transform: translateX(0);
  }
}

@keyframes moveInRight {
  /* when animation starts */
  0% {
    opacity: 0;
    /* move it to the 10rem to the left from current position */
    transform: translateX(10rem);
  }

  /* before completing animation, shift it 10% to the right, then shift it to normal (0) when at 100%*/
  80% {
    transform: translateX(-1rem);
  }

  /* when animation finishes */
  100% {
    opacity: 1;
    /* at the end show it the way it looks without animation*/
    transform: translateX(0);
  }
}

@keyframes moveInBottom {
  /* when animation starts */
  0% {
    opacity: 0;
    /* move it to the 10rem to the left from current position */
    transform: translateY(10rem);
  }

  /* before completing animation, shift it 10% to the right, then shift it to normal (0) when at 100%*/
  80% {
    transform: translateY(-1rem);
  }

  /* when animation finishes */
  100% {
    opacity: 1;
    /* at the end show it the way it looks without animation*/
    transform: translateY(0);
  }
}
/* button is a link, so it has link's pseudo selectors */
.btn:link,
.btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  font-size: 1.6rem;
  padding: 1.5rem 4rem;
  /* need to be a block if we want to give inline element padding, height, width */
  display: inline-block;
  /* to center inline-block elements (they are treated as text) add text-align to the parent element*/

  /* make button with rounded edges */
  border-radius: 10rem;

  /* use transition to animate. Use all properties for animation */
  /* transition property must be on the initial state, not on pseudo classes where it is visible */
  transition: all 0.2s;

  /* set position relative to hide the btn::after element */
  position: relative;

  /* move botton from bottom */
  animation: moveInBottom 1s ease-out;
}

.btn:hover {
  /* to move the button up (negative value) */
  transform: translateY(-0.3rem);

  /* first arg is X, the second is Y, the third is blur value, fourth - color of the shadow and its opacity */
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
}

.btn:active {
  /* when we click an element, it becomes active.
  Move the element up 1px from initial position before any actions (0)
  */
  transform: translateY(-0.1rem);

  /* when we click on the button we want the shadow to look smaller and less blured*/
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2);
}

.btn--white {
  background-color: #fff;
  color: #777;
}

/* after pseudo element is treated as a child of the button */
.btn::after {
  /* create a copy of the button and put it behind the button.
    When we hover out of the button, ... */

  /* in order for after pseudo element to appear on the page, we must have content property. */
  content: "";
  display: inline-block;
  /* 100% of the height and width of the button.  */
  height: 100%;
  width: 100%;
  border-radius: 10rem;
  /* put the pseudo button right behind the main button, so it won't stick out. The parent should the .btn:link */
  position: absolute;
  top: 0;
  left: 0;

  /* really hide the button behind by setting z-index. Without it will appear in the front */
  z-index: -1;

  /* animate the button blow out. set time. Animation is always set on the original element,
  which is ::after for the second button */
  transition: all 0.4s;
}

/* make the copied pseudo element white */
.btn--white::after {
  background-color: #fff;
}

.btn:hover::after {
  /* when we hover the button, we want to do something with the clone button behind */
  /* after we hover the button increase the size ::after The blown out size is the pseudo element
  that we hid behind the button*/
  /* transform: scale(1.5); */
  transform: scaleX(1.4) scaleY(1.6);

  opacity: 0;
}

.btn--animated {
  /* .75s - delay */
  animation: moveInBottom 0.5s ease-out 0.75s;

  /* @keyframe %0 styles will be applied to the animation before it starts */
  animation-fill-mode: backwards;
}
